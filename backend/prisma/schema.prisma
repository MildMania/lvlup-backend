generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Note: Use PostgreSQL for production (Railway)
// For local development with SQLite, set DATABASE_URL=file:./dev.db

model Game {
  id                String             @id @default(cuid())
  name              String
  apiKey            String             @unique
  description       String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  experiments       ABTest[]
  aiInsights        AiInsight[]
  aiQueries         AiQuery[]
  businessEvents    BusinessEvent[]
  checkpoints       Checkpoint[]
  contextMetadata   ContextMetadata[]
  crashLogs         CrashLog[]
  events            Event[]
  playerCheckpoints PlayerCheckpoint[]
  releases          Release[]
  configs           RemoteConfig[]
  configDrafts      ConfigDraft[]
  deployments       Deployment[]
  sessions          Session[]
  users             User[]
  gameAccesses      GameAccess[]
  revenueEvents     Revenue[]
  levelMetricsDaily LevelMetricsDaily[]
  levelMetricsDailyUsers LevelMetricsDailyUser[]
  activeUsersDaily ActiveUsersDaily[]
  activeUsersHllDaily ActiveUsersHllDaily[]
  cohortRetentionDaily CohortRetentionDaily[]
  cohortSessionMetricsDaily CohortSessionMetricsDaily[]

  @@map("games")
}

model User {
  id                String             @id @default(cuid())
  gameId            String
  externalId        String
  deviceId          String?
  platform          String?
  version           String?
  country           String?
  language          String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  aiQueries         AiQuery[]
  events            Event[]
  playerCheckpoints PlayerCheckpoint[]
  sessions          Session[]
  revenueEvents     Revenue[]
  game              Game               @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@unique([gameId, externalId])
  @@map("users")
}

model Session {
  id            String    @id @default(cuid())
  gameId        String
  userId        String
  startTime     DateTime  @default(now())
  endTime       DateTime?
  duration      Int?
  lastHeartbeat DateTime? // Track last heartbeat for automatic session closure
  platform      String?
  version       String?
  countryCode   String? // ISO country code (e.g., "MX", "US", "TR")
  events        Event[]
  revenueEvents Revenue[]
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  game          Game      @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, userId, startTime])
  @@index([gameId, startTime])
  @@index([endTime, lastHeartbeat]) // Index for heartbeat cleanup queries
  @@map("sessions")
}

model Event {
  id         String   @id @default(cuid())
  gameId     String
  userId     String
  sessionId  String?
  eventName  String
  properties Json?
  timestamp  DateTime @default(now()) // Event time (validated client timestamp or server time)

  // AB Test assignments - stored directly in event for fast filtering
  abTests Json? // { "test_id_1": "variant_a", "test_id_2": "variant_b" }

  // Level Funnel tracking - for comparing different level design iterations
  levelFunnel        String? // e.g., "live_v1", "live_v2", "test_hard"
  levelFunnelVersion Int? // Incremental version number: 1, 2, 3, etc.

  // Event metadata (like GameAnalytics)
  eventUuid        String? // Unique event identifier from client
  clientTs         BigInt? // Client-side Unix timestamp (milliseconds)
  serverReceivedAt DateTime? // Server timestamp when event was received

  // Device & Platform info
  platform     String? // e.g., "android", "ios", "webgl"
  osVersion    String? // e.g., "android 13", "iOS 16.0"
  manufacturer String? // e.g., "TECNO", "Apple"
  device       String? // e.g., "TECNO BG6", "iPhone 14"
  deviceId     String? // Unique device identifier

  // App info
  appVersion    String? // e.g., "0.0.3"
  appBuild      String? // e.g., "30087"
  sdkVersion    String? // e.g., "unity 1.0.0"

  // Network & Additional
  connectionType String? // e.g., "wifi", "wwan", "offline"
  sessionNum     Int? // Session number for this user

  // Geographic location (kept minimal)
  countryCode String? // ISO 3166-1 alpha-2, e.g., "US"

  session Session? @relation(fields: [sessionId], references: [id])
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  game    Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([gameId, timestamp])
  @@index([gameId, userId, timestamp])
  @@index([gameId, appVersion, timestamp])
  @@map("events")
}

// ============================================
// REVENUE & MONETIZATION TRACKING
// ============================================

model Revenue {
  id        String   @id @default(cuid())
  gameId    String
  userId    String
  sessionId String?
  
  // Revenue Type & Core Metrics
  revenueType RevenueType // "AD_IMPRESSION" or "IN_APP_PURCHASE"
  revenue     Float // Revenue amount in original currency
  currency    String      @default("USD") // ISO 4217 currency code
  revenueUSD  Float       @default(0) // Revenue amount converted to USD (for aggregation)
  
  // Timing (with server timestamp tracking)
  timestamp           DateTime
  serverReceivedAt    DateTime  @default(now())
  transactionTimestamp BigInt? // Original transaction timestamp from store/ad network
  
  // === AD IMPRESSION FIELDS (populated when revenueType = AD_IMPRESSION) ===
  adNetworkName       String? // e.g., "MAX", "AdMob", "IronSource", "Unity Ads"
  adFormat            String? // e.g., "BANNER", "INTER", "REWARDED", "MREC", "APPOPEN"
  adUnitId            String? // Ad unit identifier
  adUnitName          String? // Ad unit name
  adPlacement         String? // Ad placement identifier
  adCreativeId        String? // Creative asset identifier
  adImpressionId      String? // Unique impression identifier from ad network
  adNetworkPlacement  String? // Network-specific placement info
  
  // === IN-APP PURCHASE FIELDS (populated when revenueType = IN_APP_PURCHASE) ===
  productId           String? // Store product identifier (e.g., "com.game.coins_100")
  productName         String? // Product display name
  productType         String? // "CONSUMABLE", "NON_CONSUMABLE", "SUBSCRIPTION"
  transactionId       String? // Unique transaction ID from store (Apple/Google)
  orderId             String? // Order identifier from store
  purchaseToken       String? // Purchase verification token
  store               String? // "APPLE_APP_STORE", "GOOGLE_PLAY", "AMAZON", etc.
  isVerified          Boolean @default(false) // Receipt validation status
  quantity            Int?    @default(1) // Number of items purchased
  isSandbox           Boolean @default(false) // Sandbox/test transaction
  isRestored          Boolean @default(false) // Restored purchase
  subscriptionPeriod  String? // e.g., "P1M", "P1Y" (ISO 8601 duration)
  
  // Device & Platform Context (essential fields only)
  platform    String? // e.g., "android", "ios", "webgl"
  device      String? // e.g., "iPhone 14", "Samsung Galaxy"
  deviceId    String? // Device identifier
  
  // App Context
  appVersion  String? // e.g., "0.0.3"
  appBuild    String? // e.g., "30087"
  
  // Geographic Context
  countryCode String? // ISO 3166-1 alpha-2
  
  // Custom data
  customData  Json? // Flexible JSON payload for additional fields
  
  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  game    Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  session Session? @relation(fields: [sessionId], references: [id])
  
  // Essential indexes only (minimized for storage efficiency)
  @@index([gameId, revenueType, timestamp]) // Covers most revenue queries + time-series
  @@index([userId, timestamp]) // User revenue history & LTV
  
  @@map("revenue")
}

model RemoteConfig {
  id              String           @id @default(cuid())
  gameId          String
  key             String
  value           Json
  dataType        String           // "string", "number", "boolean", "json"
  environment     String           @default("production")
  enabled         Boolean          @default(true)
  description     String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  game            Game             @relation(fields: [gameId], references: [id], onDelete: Cascade)
  rules           RuleOverwrite[]
  history         ConfigHistory[]
  drafts          ConfigDraft[]
  validationRules ValidationRule[]

  @@unique([gameId, key, environment])
  @@index([gameId, environment, enabled])
  @@map("remote_configs")
}

model RuleOverwrite {
  id                 String        @id @default(cuid())
  configId           String
  priority           Int           // Unique per config, ascending order
  enabled            Boolean       @default(true)
  overrideValue      Json          // Must match config dataType
  platformConditions Json?         // Array of platforms with version ranges: [{ platform: "iOS", minVersion: "1.0.0", maxVersion: "2.0.0" }]
  countryConditions  Json?         // Array of ISO 3166-1 alpha-2 codes: ["US", "GB", "CA"]
  segmentConditions  Json?         // Array of segment IDs: ["new_users", "all_users"]
  activeBetweenStart DateTime?     // Start date for activation (inclusive)
  activeBetweenEnd   DateTime?     // End date for activation (inclusive)
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  config             RemoteConfig  @relation(fields: [configId], references: [id], onDelete: Cascade)
  history            RuleHistory[]

  @@unique([configId, priority])
  @@index([configId, priority, enabled])
  @@map("rule_overwrites")
}

model ConfigHistory {
  id            String       @id @default(cuid())
  configId      String
  changeType    String       // "created", "updated", "deleted", "rollback"
  previousValue Json?
  newValue      Json
  changedBy     String       // User ID or "system"
  changedAt     DateTime     @default(now())
  config        RemoteConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId, changedAt])
  @@map("config_history")
}

model ConfigDraft {
  id            String       @id @default(cuid())
  configId      String
  gameId        String
  key           String
  value         Json
  dataType      String
  environment   String
  enabled       Boolean      @default(true)
  description   String?
  changes       Json         // Track what changed: {"value": {...}, "description": "..."}
  status        String       @default("draft") // "draft", "pending", "deployed", "rejected"
  createdBy     String       // User ID
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  deployedAt    DateTime?
  deployedBy    String?      // User ID who deployed
  rejectionReason String?    // If rejected
  config        RemoteConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  game          Game         @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([configId, status])
  @@index([gameId, status])
  @@index([createdAt])
  @@map("config_drafts")
}

model RuleHistory {
  id            String         @id @default(cuid())
  ruleId        String?        // Nullable (preserved after rule deletion)
  configId      String
  action        String         // "created", "updated", "deleted", "reordered"
  previousState Json?
  newState      Json?
  changedBy     String
  changedAt     DateTime       @default(now())
  rule          RuleOverwrite? @relation(fields: [ruleId], references: [id], onDelete: SetNull)

  @@index([configId, changedAt])
  @@map("rule_history")
}

model ValidationRule {
  id        String       @id @default(cuid())
  configId  String
  ruleType  String       // "min", "max", "regex", "maxLength"
  ruleValue String
  config    RemoteConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@map("validation_rules")
}

model ABTest {
  id           String           @id @default(cuid())
  gameId       String
  name         String
  description  String?
  status       TestStatus       @default(DRAFT)
  trafficSplit Float            @default(0.5)
  startDate    DateTime?
  endDate      DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  game         Game             @relation(fields: [gameId], references: [id], onDelete: Cascade)
  assignments  TestAssignment[]
  variants     TestVariant[]

  @@map("ab_tests")
}

model TestVariant {
  id          String           @id @default(cuid())
  testId      String
  name        String
  description String?
  config      Json
  weight      Float            @default(0.5)
  assignments TestAssignment[]
  test        ABTest           @relation(fields: [testId], references: [id], onDelete: Cascade)

  @@map("test_variants")
}

model TestAssignment {
  id         String      @id @default(cuid())
  testId     String
  variantId  String
  userId     String
  assignedAt DateTime    @default(now())
  variant    TestVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  test       ABTest      @relation(fields: [testId], references: [id], onDelete: Cascade)

  @@unique([testId, userId])
  @@map("test_assignments")
}

model Checkpoint {
  id                String             @id @default(cuid())
  gameId            String
  name              String
  description       String?
  type              String
  tags              Json?
  order             Int?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  game              Game               @relation(fields: [gameId], references: [id], onDelete: Cascade)
  playerCheckpoints PlayerCheckpoint[]

  @@unique([gameId, name])
  @@map("checkpoints")
}

model PlayerCheckpoint {
  id           String     @id @default(cuid())
  gameId       String
  userId       String
  checkpointId String
  timestamp    DateTime   @default(now())
  metadata     Json?
  checkpoint   Checkpoint @relation(fields: [checkpointId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  game         Game       @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@unique([userId, checkpointId])
  @@index([gameId, userId, timestamp])
  @@map("player_checkpoints")
}

model Release {
  id          String           @id @default(cuid())
  version     String           @unique
  releaseDate DateTime
  description String?
  gameId      String?
  rolloutType String           @default("full")
  status      String           @default("active")
  tags        Json?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  features    ReleaseFeature[]
  game        Game?            @relation(fields: [gameId], references: [id])

  @@map("releases")
}

model ReleaseFeature {
  id               String    @id @default(cuid())
  releaseId        String
  name             String
  description      String?
  type             String
  expectedImpact   String?
  impactMetrics    Json?
  rolloutStartDate DateTime?
  rolloutEndDate   DateTime?
  createdAt        DateTime  @default(now())
  release          Release   @relation(fields: [releaseId], references: [id], onDelete: Cascade)

  @@map("release_features")
}

model BusinessEvent {
  id          String    @id @default(cuid())
  name        String
  description String?
  type        String
  startDate   DateTime
  endDate     DateTime?
  gameId      String?
  impact      String?
  metadata    Json?
  tags        Json?
  createdAt   DateTime  @default(now())
  game        Game?     @relation(fields: [gameId], references: [id])

  @@map("business_events")
}

model AiQuery {
  id           String      @id @default(cuid())
  query        String
  queryType    String
  context      Json?
  response     String?
  responseType String?
  confidence   Float?
  gameId       String?
  userId       String?
  createdAt    DateTime    @default(now())
  insights     AiInsight[]
  user         User?       @relation(fields: [userId], references: [id])
  game         Game?       @relation(fields: [gameId], references: [id])

  @@map("ai_queries")
}

model AiInsight {
  id          String   @id @default(cuid())
  queryId     String?
  title       String
  description String
  type        String
  confidence  Float
  gameId      String?
  dateRange   Json?
  metrics     Json?
  metadata    Json?
  status      String   @default("active")
  createdAt   DateTime @default(now())
  query       AiQuery? @relation(fields: [queryId], references: [id])
  game        Game?    @relation(fields: [gameId], references: [id])

  @@map("ai_insights")
}

model ContextMetadata {
  id          String    @id @default(cuid())
  type        String
  description String
  dateRange   Json?
  gameId      String?
  metadata    Json
  computedAt  DateTime  @default(now())
  validUntil  DateTime?
  status      String    @default("active")
  game        Game?     @relation(fields: [gameId], references: [id])

  @@map("context_metadata")
}

model CrashLog {
  id        String  @id @default(cuid())
  gameId    String
  userId    String?
  sessionId String?

  // Crash details
  crashType     String // "exception", "crash", "anr"
  severity      String  @default("ERROR") // "LOW", "MEDIUM", "HIGH", "CRITICAL", "ERROR", "WARNING"
  message       String
  stackTrace    String
  exceptionType String? // e.g., "NullReferenceException", "IndexOutOfRangeException"

  // Device & Platform info
  platform     String?
  osVersion    String?
  manufacturer String?
  device       String?
  deviceId     String?

  // App info
  appVersion    String?
  appBuild      String?
  bundleId      String?
  engineVersion String?
  sdkVersion    String?

  // Context
  country        String?
  connectionType String?
  memoryUsage    Int? // Memory usage in bytes (using Int instead of BigInt for SQLite)
  batteryLevel   Float? // Battery level 0-1
  diskSpace      Int? // Available disk space in bytes (using Int instead of BigInt for SQLite)

  // Additional metadata
  breadcrumbs String? // JSON string of breadcrumbs leading to crash
  customData  String? // JSON string of custom key-value pairs

  timestamp  DateTime  @default(now())
  resolved   Boolean   @default(false)
  resolvedAt DateTime?

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, timestamp])
  @@index([gameId, platform, timestamp])
  @@index([gameId, appVersion, timestamp])
  @@index([gameId, crashType, timestamp])
  @@index([gameId, severity, timestamp])
  @@map("crash_logs")
}

// ============================================
// DASHBOARD USER AUTHENTICATION & AUTHORIZATION
// ============================================

// Dashboard user account (developers/admins accessing analytics dashboard)
model DashboardUser {
  id           String @id @default(cuid())
  email        String @unique
  passwordHash String
  firstName    String
  lastName     String

  // Account status
  isEmailVerified          Boolean   @default(false)
  emailVerificationToken   String?   @unique
  emailVerificationExpires DateTime?

  isActive   Boolean @default(true)
  isLocked   Boolean @default(false)
  lockReason String?

  // Password reset
  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?

  // Failed login tracking
  failedLoginAttempts Int       @default(0)
  lastFailedLogin     DateTime?

  // Metadata
  lastLogin   DateTime?
  lastLoginIp String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  teamMemberships    TeamMember[]
  gameAccesses       GameAccess[]
  sentInvitations    Invitation[]   @relation("InvitedBy")
  receivedInvitation Invitation?    @relation("InvitedUser")
  refreshTokens      RefreshToken[]
  twoFactorAuth      TwoFactorAuth?
  auditLogs          AuditLog[]
  createdBy          String? // DashboardUser ID who created this account

  @@map("dashboard_users")
}

// Teams for organizing users and game access
model Team {
  id          String  @id @default(cuid())
  name        String
  description String?
  slug        String  @unique

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  members      TeamMember[]
  gameAccesses GameAccess[]
  invitations  Invitation[]

  @@map("teams")
}

// Team membership with roles
model TeamMember {
  id     String        @id @default(cuid())
  teamId String
  userId String
  role   DashboardRole

  joinedAt  DateTime @default(now())
  updatedAt DateTime @updatedAt

  team Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user DashboardUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

// Game access for teams or individual users
model GameAccess {
  id String @id @default(cuid())

  // Access can be team-based or user-based
  teamId String?
  userId String?

  // Access can be for specific game or all games
  gameId   String?
  allGames Boolean @default(false)

  // Access level
  accessLevel AccessLevel

  // Grant info
  grantedAt DateTime  @default(now())
  grantedBy String? // DashboardUser ID
  expiresAt DateTime?

  team Team?          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user DashboardUser? @relation(fields: [userId], references: [id], onDelete: Cascade)
  game Game?          @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([teamId, gameId])
  @@index([userId, gameId])
  @@map("game_accesses")
}

// Email invitations
model Invitation {
  id    String @id @default(cuid())
  email String
  token String @unique

  // Invitation details
  teamId String?
  role   DashboardRole

  // Game access included in invitation
  gameIds     Json? // Array of game IDs or null for all
  accessLevel AccessLevel

  // Status
  status InvitationStatus @default(PENDING)

  // Metadata
  invitedBy  String
  acceptedBy String? @unique

  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  acceptedAt DateTime?
  revokedAt  DateTime?

  inviter      DashboardUser  @relation("InvitedBy", fields: [invitedBy], references: [id], onDelete: Cascade)
  acceptedUser DashboardUser? @relation("InvitedUser", fields: [acceptedBy], references: [id])
  team         Team?          @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([email, status])
  @@index([token])
  @@map("invitations")
}

// JWT refresh tokens
model RefreshToken {
  id     String @id @default(cuid())
  userId String
  token  String @unique

  expiresAt DateTime
  createdAt DateTime @default(now())

  // Device/session tracking
  userAgent String?
  ipAddress String?

  user DashboardUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
  @@map("refresh_tokens")
}

// Two-factor authentication
model TwoFactorAuth {
  id     String @id @default(cuid())
  userId String @unique

  isEnabled   Boolean @default(false)
  secret      String // Encrypted TOTP secret
  backupCodes Json // Array of hashed backup codes

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  user DashboardUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("two_factor_auth")
}

// Audit logs for security and compliance
model AuditLog {
  id       String  @id @default(cuid())
  userId   String?
  action   String // e.g., "USER_LOGIN", "GAME_CREATED", "ROLE_CHANGED"
  resource String? // e.g., "Game:abc123", "Team:xyz789"
  details  Json?

  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  user DashboardUser? @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@map("audit_logs")
}

// Deployment history for staging/production environments
model Deployment {
  id          String   @id @default(cuid())
  gameId      String
  environment String   // 'staging' or 'production'
  version     Int      // Auto-increment: 1, 2, 3, etc.
  deployedBy  String
  deployedAt  DateTime @default(now())
  source      String   // 'stash-from-dev', 'publish-from-staging', or 'rollback'
  
  // Complete snapshot of configs and rules at deployment time
  snapshot    Json     // { configs: [...], rules: {...} }
  
  // Rollback information (only for staging)
  isRollback     Boolean @default(false)
  rolledBackFrom String? // deployment ID that was rolled back
  
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, environment, deployedAt])
  @@index([gameId, environment, version])
  @@map("deployments")
}

// Enums for Dashboard Authentication
enum DashboardRole {
  SUPER_ADMIN
  ADMIN
  GAME_OWNER
  EDITOR
  VIEWER
}

enum AccessLevel {
  OWNER // Full control
  EDITOR // Can modify
  VIEWER // Read-only
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

enum TestStatus {
  DRAFT
  RUNNING
  PAUSED
  COMPLETED
}

enum RevenueType {
  AD_IMPRESSION
  IN_APP_PURCHASE
}

// ============================================
// PRE-AGGREGATED ANALYTICS
// ============================================

model LevelMetricsDaily {
  id        String   @id @default(cuid())
  gameId    String
  date      DateTime // Daily aggregation (date only, time set to 00:00:00)
  levelId   Int
  
  // Filter dimensions (indexed for fast queries)
  levelFunnel        String  @default("")
  levelFunnelVersion Int     @default(0)
  platform           String  @default("") // iOS, Android, etc.
  countryCode        String  @default("") // US, TR, etc.
  appVersion         String  @default("") // 0.1, 0.2, etc.
  
  // Core event counts (NOT user counts)
  starts             Int @default(0)
  completes          Int @default(0)
  fails              Int @default(0)
  
  // Daily unique player counts
  startedPlayers     Int @default(0)
  completedPlayers   Int @default(0)
  
  // Booster & EGP metrics
  boosterUsers       Int @default(0) // Count of unique users who used boosters
  totalBoosterUsage  Int @default(0) // Total number of boosters used (sum across all events)
  egpUsers           Int @default(0) // Count of unique users who used EGP
  totalEgpUsage      Int @default(0) // Total number of EGP purchases (sum across all events)
  
  // Duration metrics (for calculating averages)
  totalCompletionDuration BigInt @default(0) // Sum of completion durations in seconds
  completionCount         Int    @default(0) // Number of matched start->complete pairs
  
  totalFailDuration       BigInt @default(0) // Sum of fail durations in seconds
  failCount               Int    @default(0) // Number of matched start->fail pairs
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
  
  // Composite indexes for fast filtering
  @@index([gameId, date])
  @@index([gameId, date, levelId])
  @@index([gameId, levelFunnel, levelFunnelVersion, date])
  @@index([platform])
  @@index([countryCode])
  @@index([appVersion])
  
  // Unique constraint to prevent duplicates (empty strings for nulls)
  @@unique([gameId, date, levelId, levelFunnel, levelFunnelVersion, platform, countryCode, appVersion], name: "unique_daily_metrics")
  @@map("level_metrics_daily")
}

model LevelMetricsDailyUser {
  id        String   @id @default(cuid())
  gameId    String
  date      DateTime // Daily aggregation (date only, time set to 00:00:00)
  levelId   Int

  // Filter dimensions (indexed for fast queries)
  levelFunnel        String  @default("")
  levelFunnelVersion Int     @default(0)
  platform           String  @default("") // iOS, Android, etc.
  countryCode        String  @default("") // US, TR, etc.
  appVersion         String  @default("") // 0.1, 0.2, etc.

  userId      String
  started     Boolean @default(false)
  completed   Boolean @default(false)
  boosterUsed Boolean @default(false)
  egpUsed     Boolean @default(false)

  createdAt DateTime @default(now())

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, date])
  @@index([gameId, date, levelId])
  @@index([gameId, levelFunnel, levelFunnelVersion, date])
  @@index([userId])
  @@unique([gameId, date, levelId, levelFunnel, levelFunnelVersion, platform, countryCode, appVersion, userId], name: "unique_daily_level_user")
  @@map("level_metrics_daily_users")
}

model ActiveUsersDaily {
  id          String   @id @default(cuid())
  gameId      String
  date        DateTime // Daily aggregation (date only, time set to 00:00:00)
  platform    String   @default("")
  countryCode String   @default("")
  appVersion  String   @default("")
  dau         Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, date])
  @@index([gameId, date, platform, countryCode, appVersion])
  @@unique([gameId, date, platform, countryCode, appVersion], name: "unique_active_users_daily")
  @@map("active_users_daily")
}

model ActiveUsersHllDaily {
  id          String   @id @default(cuid())
  gameId      String
  date        DateTime // Daily aggregation (date only, time set to 00:00:00)
  platform    String   @default("")
  countryCode String   @default("")
  appVersion  String   @default("")
  hll         Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, date])
  @@index([gameId, date, platform, countryCode, appVersion])
  @@unique([gameId, date, platform, countryCode, appVersion], name: "unique_active_users_hll_daily")
  @@map("active_users_hll_daily")
}

model CohortRetentionDaily {
  id          String   @id @default(cuid())
  gameId      String
  installDate DateTime // Cohort install date (UTC date only)
  dayIndex    Int      // Day offset from install date
  cohortSize  Int      @default(0)
  retainedUsers Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, installDate])
  @@index([gameId, dayIndex])
  @@unique([gameId, installDate, dayIndex], name: "unique_cohort_retention_daily")
  @@map("cohort_retention_daily")
}

model CohortSessionMetricsDaily {
  id          String   @id @default(cuid())
  gameId      String
  installDate DateTime // Cohort install date (UTC date only)
  dayIndex    Int      // Day offset from install date
  cohortSize  Int      @default(0)
  sessionUsers Int     @default(0)
  totalSessions Int    @default(0)
  totalDurationSec BigInt @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, installDate])
  @@index([gameId, dayIndex])
  @@unique([gameId, installDate, dayIndex], name: "unique_cohort_session_metrics_daily")
  @@map("cohort_session_metrics_daily")
}
